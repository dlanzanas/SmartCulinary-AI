import os
import cv2
import time
import numpy as np
import random

BASE_DIR = os.path.dirname(os.path.abspath(__file__))

DATASET_DIR = os.path.join(BASE_DIR, "archive", "images")
RECIPE_PATH = os.path.join(BASE_DIR, "RECIPE.txt")

# LOW-SPEC / NO-LAG SETTINGS
MAX_SIDE = 220
NFEATURES = 550
SAMPLE_PER_CLASS = 12
EVAL_EVERY_SECONDS = 1.2
SMOOTH_FRAMES = 3
MIN_GOOD_MATCHES = 8

RATIO_TEST = 0.80
GOOD_DIST = 65

def load_recipe_map(path):
    recipes = {}
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line or "=" not in line:
                continue
            k, v = line.split("=", 1)
            recipes[k.strip().upper()] = v.strip()
    return recipes

def list_classes(dataset_dir):
    classes = []
    for d in os.listdir(dataset_dir):
        p = os.path.join(dataset_dir, d)
        if os.path.isdir(p):
            classes.append(d)
    return sorted(classes)

def list_images(class_dir):
    exts = (".jpg", ".jpeg", ".png", ".bmp", ".webp")
    files = [os.path.join(class_dir, f) for f in os.listdir(class_dir) if f.lower().endswith(exts)]
    files.sort()
    return files

def to_gray_resized(img_bgr, max_side):
    h, w = img_bgr.shape[:2]
    scale = max_side / max(h, w)
    if scale < 1.0:
        img_bgr = cv2.resize(img_bgr, (int(w * scale), int(h * scale)), interpolation=cv2.INTER_AREA)
    return cv2.cvtColor(img_bgr, cv2.COLOR_BGR2GRAY)

def sample_files(files, k):
    if k is None or len(files) <= k:
        return files
    return random.sample(files, k)

def build_signatures(dataset_dir, classes, orb):
    signatures = {}
    for c in classes:
        cdir = os.path.join(dataset_dir, c)
        all_files = list_images(cdir)
        files = sample_files(all_files, SAMPLE_PER_CLASS)

        descs = []
        for fp in files:
            im = cv2.imread(fp)
            if im is None:
                continue
            gray = to_gray_resized(im, MAX_SIDE)
            kp, des = orb.detectAndCompute(gray, None)
            if des is not None and len(des) > 0:
                descs.append(des)

        signatures[c] = descs
        print(f"Loaded {c}: {len(descs)} samples (from {len(all_files)} total)")
    return signatures

def match_score(des_live, class_descs, bf):
    if des_live is None or len(des_live) == 0:
        return 0

    best = 0
    for des_ref in class_descs:
        if des_ref is None or len(des_ref) == 0:
            continue
        matches = bf.knnMatch(des_live, des_ref, k=2)
        good = 0
        for m, n in matches:
            if m.distance < RATIO_TEST * n.distance and m.distance < GOOD_DIST:
                good += 1
        if good > best:
            best = good
    return best

def majority_vote(labels):
    if not labels:
        return "NONE"
    counts = {}
    for l in labels:
        counts[l] = counts.get(l, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]

def overlay(frame, lines):
    y = 30
    for t in lines:
        cv2.putText(frame, t, (10, y), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)
        y += 30

def main():
    if not os.path.isdir(DATASET_DIR):
        print("❌ Dataset folder not found:", DATASET_DIR)
        return
    if not os.path.exists(RECIPE_PATH):
        print("❌ RECIPE.txt not found:", RECIPE_PATH)
        return

    recipes = load_recipe_map(RECIPE_PATH)
    classes = list_classes(DATASET_DIR)

    orb = cv2.ORB_create(nfeatures=NFEATURES)
    bf = cv2.BFMatcher(cv2.NORM_HAMMING)

    print("✅ Building signatures (LOW-LAG MODE)...")
    signatures = build_signatures(DATASET_DIR, classes, orb)

    cap = cv2.VideoCapture(0, cv2.CAP_DSHOW)
    if not cap.isOpened():
        print("❌ Cannot open laptop camera")
        return

    recent_preds = []
    last_eval = 0.0
    last_best_label = "NONE"
    last_best_score = 0

    print("\n✅ Running. Hold item steady. Press Q to quit.\n")

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        now = time.time()

        if (now - last_eval) >= EVAL_EVERY_SECONDS:
            gray_live = to_gray_resized(frame, MAX_SIDE)
            kp, des_live = orb.detectAndCompute(gray_live, None)

            best_label = "NONE"
            best_score = 0

            for c in classes:
                sc = match_score(des_live, signatures.get(c, []), bf)
                if sc > best_score:
                    best_score = sc
                    best_label = c

            if best_score < MIN_GOOD_MATCHES:
                best_label = "NONE"

            recent_preds.append(best_label)
            if len(recent_preds) > SMOOTH_FRAMES:
                recent_preds.pop(0)

            last_best_label = best_label
            last_best_score = best_score
            last_eval = now

        final_label = majority_vote(recent_preds)
        ingredients = recipes.get(final_label, "(no recipe mapping)")

        lines = [
            "SmartCulinary AI (No-Lag Folder Matching)",
            f"Detected: {final_label}",
            f"Score: {last_best_score} | Updates every {EVAL_EVERY_SECONDS}s",
            "Ingredients:",
            ingredients[:80] + ("..." if len(ingredients) > 80 else ""),
            "Hold item close | Good lighting | Q to quit"
        ]

        overlay(frame, lines)
        cv2.imshow("SmartCulinary AI", frame)

        if (cv2.waitKey(1) & 0xFF) == ord("q"):
            break

    cap.release()
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()

